package gopherdb

import (
	"fmt"
	"strings"
)

// IndexOptions represents the options for an index.
type IndexOptions struct {
	Name          string `json:"name"`
	Unique        bool   `json:"unique"`
	Autogenerated bool   `json:"autogenerated"`
}

// NewIndexOptions creates a new index options.
func NewIndexOptions() *IndexOptions {
	return &IndexOptions{}
}

// SetName sets the name of the index options.
func (o *IndexOptions) SetName(name string) *IndexOptions {
	o.Name = name

	return o
}

// SetUnique sets the unique flag of the index options.
func (o *IndexOptions) SetUnique(unique bool) *IndexOptions {
	o.Unique = unique

	return o
}

// Value returns the index options.
func (o *IndexOptions) Value() IndexOptions {
	return *o
}

// IndexField represents a field in an index.
type IndexField struct {
	Name  string `json:"name"`
	Order int    `json:"order"`
}

// IndexModel represents a model for an index.
type IndexModel struct {
	Fields  []IndexField `json:"fields"`
	Options IndexOptions `json:"options"`
}

// NewIndexModel creates a new index model.
func NewIndexModel() *IndexModel {
	return &IndexModel{
		Fields:  make([]IndexField, 0),
		Options: IndexOptions{},
	}
}

// AddField adds a field to the index model.
func (index *IndexModel) AddField(name string, order int) *IndexModel {
	index.Fields = append(index.Fields, IndexField{Name: name, Order: order})

	return index
}

// SetOptions sets the options for the index model.
func (index *IndexModel) SetName(name string) *IndexModel {
	index.Options.Name = name

	return index
}

// SetUnique sets the unique flag of the index model.
func (index *IndexModel) SetUnique(unique bool) *IndexModel {
	index.Options.Unique = unique

	return index
}

// Value returns the index model.
func (index *IndexModel) Value() IndexModel {
	return *index
}

// isValid checks if the index model is valid.
func (index *IndexModel) validate() error {
	if index.Fields == nil || len(index.Fields) == 0 {
		return ErrEmptyIndexFields
	}

	if strings.TrimSpace(index.Options.Name) == "" {
		name := ""

		for _, f := range index.Fields {
			name += fmt.Sprintf("_%s_%d", f.Name, f.Order)
		}

		index.Options.Name = strings.TrimPrefix(name, "_")
	}

	if index.isCompound() {
		seen := make(map[string]struct{})

		for _, f := range index.Fields {
			if _, ok := seen[f.Name]; ok {
				return ErrDuplicateIndexField
			}
		}
	}

	return nil
}

// isCompound checks if the index model is a compound index.
func (index IndexModel) isCompound() bool {
	return len(index.Fields) > 1
}

// isUnique checks if the index model is unique.
func (index IndexModel) isUnique() bool {
	return index.Options.Unique
}

// isAutogenerated checks if the index model is autogenerated.
func (index IndexModel) isAutogenerated() bool {
	return index.Options.Autogenerated
}

// splitCompoundIndex splits a compound index into multiple single field indexes.
func (index IndexModel) splitCompoundIndex() []IndexModel {
	if index.isCompound() {
		l := (len(index.Fields) * 2)
		results := make([]IndexModel, l)

		for i := range index.Fields {
			// Índice ascendente
			results[i*2] = IndexModel{
				Fields: []IndexField{
					{Name: index.Fields[i].Name, Order: 1},
				},
				Options: IndexOptions{
					Name:          fmt.Sprintf("%s_1", index.Fields[i].Name),
					Autogenerated: true,
				},
			}

			// Índice descendente
			results[i*2+1] = IndexModel{
				Fields: []IndexField{
					{Name: index.Fields[i].Name, Order: -1},
				},
				Options: IndexOptions{
					Name:          fmt.Sprintf("%s_-1", index.Fields[i].Name),
					Autogenerated: true,
				},
			}
		}

		return append(results, index)
	}

	return []IndexModel{index}
}

// splitCompoundIndexes splits all compound indexes in the list.
func splitCompoundIndexes(indexes []IndexModel) []IndexModel {
	results := make([]IndexModel, 0)

	for _, index := range indexes {
		results = append(results, index.splitCompoundIndex()...)
	}

	return results
}
